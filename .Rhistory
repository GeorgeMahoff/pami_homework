x=1
x = rnorm(50)
y = x + rnorm(50,10,.1)
plot(x,y)
y = x + rnorm(50,10,.5)
plot(x,y)
y = x + rnorm(50,10,.5)
y = x + rnorm(50,10,.5)
plot(x,y)
y = x + rnorm(50,10,.1)
plot(x,y)
y = x + rnorm(50,10,.5)
plot(x,y)
add2(3, 5)
}
x + y
a + b
a
add2 <- function(a, b) {
a + b
}
add2(3,5)
cube <- function(x, n){
x^3
}
cube(3)
cube <- function(x, n){
x <- 1:10
if (x > 5) {
x<-0
}
}
cube(3)
cube <- function(x, n){
x <- 1:10
//if (x > 5) {
//  x<-0
//}
x
}
x <- 1:10
cube(3)
cube <- function(x, n){
x <- 1:10
x
}
cube(3)
cube <- function(x, n){
x <- 1:10
x+1
}
cube(3)
cube <- function(){
x <- 1:10
x+1
}
cube(3)
cube()
}
f <- function(x) {
g <- function(y) {
y + z
}
z <- 4
x + g(x)
}
z<-10
f(3)
above10 <- function() {
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
}
above10()
above10()
above10 <- function() {
x <- 5
y <- if(x < 3) {
NA
} else {
10
}
y
}
above10()
datasets(mtcars)
library(datasets)
data(mtcars)
mtcars
View(mtcars)
split(mtcars,mtcars$cyl)
s <- split(mtcars,mtcars$cyl)
s[1]
lapply(s)
lapply(s, mean)
s[1]
apply(s, mean)
mapply(s, mean)
tapply(s, mean)
s[1]
colMeans(s[, hp])
colMeans(s[, c(hp)])
colMeans(s[, c("hp")])
colMeans(s[, "hp"])
lapply(s, function(x) colmeans(x[, "hp"]))
lapply(s, function(x) colMeans(x[, "hp"]))
lapply(s, function(x) colMeans(x[, c("hp","cyl"]))
lapply(s, function(x) colMeans(x[, c("hp","cyl")]))
abs(82.63636, 209.2143)
abs(82.63636)
abs(82.63636 - 209.2143)
x <- rep(0:1, each = 5)
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
plot(x,y)
R.version.string
install.packages("swirl")
library(swirl)
swirl()
library(swirl)
install_from_swirl("R Programming")
y
library(swirl)
swirl()
5+7
x <- 5+7
x
y<-x-3
y
z <- c(1.1, 9 ,3.14)
?c
z
c(z,555,z)
z*2 +100
sqrt(z-1)
my_sqrt(z-1)
my_sqrt<-sqrt(z-1)
my_sqrt
my_div<-div(z,my_sqrt)
install(kernlab)
install.packeges("kernlab")
install.packages("kernlab")
install.packages("caret")
library("kernlab")
dataset("spam")
data(spam)
View(spam)
inTrain <- createPartition(y=spam$type, p=0.75, list = false)
library("caret")
library("caret")
inTrain <- createPartition(y=spam$type, p=0.75, list = false)
inTrain <- createDataPartition(y=spam$type, p=0.75, list = false)
inTrain <- createDataPartition(y=spam$type, p=0.75, list = FALSE)
View(inTrain)
View(spam)
View(inTrain)
training <- spam[inTrain,]
testing <- spam[-inTrain,]
dim(training)
View(training)
View(training)
View(testing)
View(training)
modelFit <- train(type)
q
modelFit <- train(type ˜., data=training, method = "glm")
modelFit <- train(type˜., data=training, method = "glm")
modelFit <- train(type ~., data=training, method = "glm")
install.packages("e1071")
modelFit <- train(type ~., data=training, method = "glm")
view(ModelFit)
modelFit
install.packages("shiny")
install.packages(XLConnect)
install.packages("XLConnect")
library(XLConnect)
r.version
lm
dgamma
colSums
library(leaps)
rm(list=ls())
################################# MAIN CODE ###########################################
cat("
-------------------------------------------------------------------------------------
Welcome to the first PAMI demo/homework (year 2016): linear regression
data = read.table("cirrhosis.data",header = TRUE)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
View(m)
View(m)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
# try to run the following code manually, change dim and comment the results of summary(d)
dim = 2
m <- matrix(runif(dim*N,-1,1), ncol=dim)
d = sqrt(rowSums(m^2))
summary(d)
View(m)
dim = 2
m <- matrix(runif(dim*N,-1,1), ncol=dim)
d = sqrt(rowSums(m^2))
summary(d)
dim = 10
m <- matrix(runif(dim*N,-1,1), ncol=dim)
d = sqrt(rowSums(m^2))
summary(d)
dim = 100
m <- matrix(runif(dim*N,-1,1), ncol=dim)
d = sqrt(rowSums(m^2))
summary(d)
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
source('~/.active-rstudio-document')
N=2
dim = 2
m <- matrix(runif(dim*N,-1,1), ncol=dim)
d = sqrt(rowSums(m^2))
View(m)
d
m
vol_of_sphere <- function(dim, N) {
m <- matrix(runif(dim*N,-1,1), ncol=dim)
sum(sqrt(rowSums(m^2)) <= 1) / N
}
rand_dist_origin <- function(N,dim) {
m <- matrix(rnorm(N*dim),ncol=dim)
v <- sqrt(rowSums(m^2))
return(c(avg = mean(v), min = min(v), max = max(v)))
}
perform_lda_prediction <- function(fit, data, labels) {
pred = predict(fit, as.data.frame(data))
class = pred$class
table(class,labels)
mean(class == labels)
}
N = 100 # this is the number of points filling the hyperbox, decrease if too slow
df <- data.frame(
dim <- 1:15,
v <- sapply(1:15, function(dim) vol_of_sphere(dim,N))
)
View(df)
dim = 3
m <- matrix(runif(dim*N,-1,1), ncol=dim)
d = sqrt(rowSums(m^2))
summary(d)
dim = 7
m <- matrix(runif(dim*N,-1,1), ncol=dim)
d = sqrt(rowSums(m^2))
summary(d)
dim = 9
m <- matrix(runif(dim*N,-1,1), ncol=dim)
d = sqrt(rowSums(m^2))
summary(d)
dim = 15
m <- matrix(runif(dim*N,-1,1), ncol=dim)
d = sqrt(rowSums(m^2))
summary(d)
df <- data.frame(
dim = 2:max_dim,
aggregation = as.factor(c(rep("min", length(v["min",])), rep("max", length(v["max",])), rep("avg", length(v["avg",])))),
v = c(v["min",], v["max",], v["avg",])
)
max_dim <- 100
N = 100
v <- mapply(rand_dist_origin, rep(100000,max_dim-1), 2:max_dim)
df <- data.frame(
dim = 2:max_dim,
aggregation = as.factor(c(rep("min", length(v["min",])), rep("max", length(v["max",])), rep("avg", length(v["avg",])))),
v = c(v["min",], v["max",], v["avg",])
)
View(df)
View(df)
View(m)
rand_dist_origin <- function(N,dim) {
m <- matrix(rnorm(N*dim),ncol=dim)
v <- sqrt(rowSums(m^2))
return(c(avg = mean(v), min = min(v), max = max(v), rel = ((max(v)-min(v))/min(v)))
}
rand_dist_origin <- function(N,dim) {
m <- matrix(rnorm(N*dim),ncol=dim)
v <- sqrt(rowSums(m^2))
return(c(avg = mean(v), min = min(v), max = max(v), rel = ((max(v)-min(v))/min(v))))
}
max_dim <- 100
N = 1000
v <- mapply(rand_dist_origin, rep(N,max_dim-1), 2:max_dim)
View(v)
View(df)
max_dim <- 100
N = 10000
v <- mapply(rand_dist_origin, rep(N,max_dim-1), 5:max_dim)
df <- data.frame(
dim = 5:max_dim,
aggregation = as.factor(c(rep("min", length(v["min",])), rep("max", length(v["max",])), rep("avg", length(v["avg",])),rep("rel", length(v["rel",])))),
v = c(v["min",], v["max",], v["avg",], v["rel",])
)
max_dim <- 100
N = 1000
v <- mapply(rand_dist_origin, rep(N,max_dim-1), 3:max_dim)
df <- data.frame(
dim = 3:max_dim,
aggregation = as.factor(c(rep("min", length(v["min",])), rep("max", length(v["max",])), rep("avg", length(v["avg",])),rep("rel", length(v["rel",])))),
v = c(v["min",], v["max",], v["avg",], v["rel",])
)
View(df)
setwd("~/Dropbox/Autumn_2015/polimi/pami/statLearningDemos")
library("jpeg")
library("png")
library("graphics")
library("ggplot2")
library("grid")
library("gridExtra")
gradient <- readJPEG("gradient.jpg")
image = gradient #just for the fast switch
k = 2
err = 2001
threshold = 2000
# Kmeans based segmenter
segment_image = function(img, n, alg="Hartigan-Wong", itm=10){
# create a flat, segmented image data set using kmeans
# Segment an RGB image into n groups based on color values using Kmeans
df = data.frame(
red = matrix(img[,,1], ncol=1),
green = matrix(img[,,2], ncol=1),
blue = matrix(img[,,3], ncol=1)
)
K = kmeans(df,centers=n,iter.max=itm,algorithm=alg)
# the function returns a structure whose attribute "cluster" contains the labels
df$label = K$cluster
# compute rgb values and color codes based on Kmeans centers
colors = data.frame(
label = 1:nrow(K$centers),
R = K$centers[,"red"],
G = K$centers[,"green"],
B = K$centers[,"blue"],
color=rgb(K$centers)
)
# merge color codes on to df but maintain the original order of df
df$order = 1:nrow(df)
df = merge(df, colors)
df = df[order(df$order),]
df$order = NULL
return(df)
}
#
# reconstitue the segmented images to RGB matrix
#
build_segmented_image = function(df, img){
# reconstitue the segmented images to RGB array
# get mean color channel values for each row of the df.
R = matrix(df$R, nrow=dim(img)[1])
G = matrix(df$G, nrow=dim(img)[1])
B = matrix(df$B, nrow=dim(img)[1])
# reconsitute the segmented image in the same shape as the input image
img_segmented = array(dim=dim(img))
img_segmented[,,1] = R
img_segmented[,,2] = G
img_segmented[,,3] = B
return(img_segmented)
}
#
# 2D projection for visualizing the kmeans clustering
#
project2D_from_RGB = function(df){
# Compute the projection of the RGB channels into 2D
PCA = prcomp(df[,c("red","green","blue")], center=TRUE, scale=TRUE)
pc2 = PCA$x[,1:2]
df$x = pc2[,1]
df$y = pc2[,2]
return(df[,c("x","y","label","R","G","B", "color")])
}
#
# Create the projection plot of the clustered segments
#
plot_projection <- function(df, sample.size){
# plot the projection of the segmented image data in 2D, using the
# mean segment colors as the colors for the points in the projection
index = sample(1:nrow(df), sample.size)
return(ggplot(df[index,], aes(x=x, y=y, col=color)) + geom_point(size=2) + scale_color_identity())
}
#
# Inspect
#
inspect_segmentation <- function(image.raw, image.segmented, image.proj){
# helper function to review the results of segmentation visually
img1 = rasterGrob(image.raw)
img2 = rasterGrob(image.segmented)
plt = plot_projection(image.proj, 50000)
grid.arrange(arrangeGrob(img1,img2, nrow=1),plt,heights=1:2, widths=3:4)
}
while(err < threshold){
image.segmented <- build_segmented_image(segment_image(image, k, "Lloyd", 1000), image)
err =  sum((image-image.segmented)^2)
k <- k+1
print(k)
}
print(err < threshold)
while(err < threshold){
image.segmented <- build_segmented_image(segment_image(image, k, "Lloyd", 1000), image)
err =  sum((image-image.segmented)^2)
k <- k+1
print(k)
}
k <- 2
err = 2001
threshold = 2000
print(err < threshold)
while(err < threshold){
image.segmented <- build_segmented_image(segment_image(image, k, "Lloyd", 1000), image)
err =  sum((image-image.segmented)^2)
k <- k+1
print(k)
}
while(err < threshold){
print('hello')
}
while(err < threshold){
print('hello');
}
err = 2001
threshold = 2000
print(err < threshold)
while(err < threshold){
print('hello');
}
k <- 2
err = 2001
threshold = 2000
while(err > threshold){
image.segmented <- build_segmented_image(segment_image(image, k, "Lloyd", 1000), image)
err =  sum((image-image.segmented)^2)
k <- k+1
print(k)
}
k <- 2
err = 2001
threshold = 2000
while(err > threshold){
image.segmented <- build_segmented_image(segment_image(image, k, "Lloyd", 1000), image)
err =  sum((image-image.segmented)^2)
k <- k+1
}
print(k-1)
